---
title: "procesamiento 2"
author: "Andres Felipe Beltran"
date: "4/13/2021"
output: 
 prettydoc::html_pretty:
    theme: cayman
---

En este documento revisaremos como organizar y preparar los archivos para el promediado. En esta carpeta solo hay espectros de muestras que necesitan ser promediadios.

```{r}
nombres <- list.files(, pattern = 'CSV')
nombres
```
```{r}
48/3
```

Ahora leemos los espectros:

```{r}
data <- lapply(nombres, read.csv, header = FALSE)
```

```{r}
str(data[[1]])
```
```{r}
wavenumber <- data[[1]][,1]
```

```{r}
data2 <- lapply(data, '[', 2)
```

```{r}
data2 <- as.data.frame(data2)
dim(data2)
names(data2) <- nombres
```
```{r}
datat <- t(data2)
colnames(datat) <- wavenumber
```



```{r}


set.seed(0)

searchGrid <-  expand.grid(Temperature = c('Room T','50C'),
                         Time = c('2 min', '4 min' , '6 min', '8 min'),
                         Treatment =c('A','B'))

rownames.prom <- character(16)

for (i in 1:16){
rownames.prom[i] <- paste(searchGrid[i,1],searchGrid[i,2],searchGrid[i,3])  
  
}
prom <- matrix(, 
               ncol= ncol(datat), 
               nrow = nrow(datat)/3)
index <- vector('list',16)

for(i in 1:16){
  
  index[[i]] <- c(which(grepl(paste0('(?=.*',
      as.character(searchGrid[i,1]),
        ')(?=.*',
        as.character(searchGrid[i,2]),
        ')(?=.*',
        as.character(searchGrid[i,3]),
        ')'
 ) , rownames(datat), perl = T))
              )
  
for(j in 1:length(colnames(datat))){
  


prom[i,j] <- mean(c(datat[index[[i]][1],j],
                 datat[index[[i]][2],j],
                 datat[index[[i]][3],j]
                      ) )

}
}
rownames(prom) <- rownames.prom
colnames(prom) <- wavenumber
 
```


Podemos graficar los promedios:

```{r}
for(i in 1:length(rownames(prom))){
  plot(wavenumber,
      prom[i,],
       xlab = 'wave number cm-1',
       ylab = 'absorbance a.u.',
       xlim = c(4000,400),
       ylim = c(0,0.1),
       type = 'l')
  par(new = T)
  
  
}
```

Podemos importar los espectros de la primera parte ya promediados para analizar todo en conjunto:

```{r}
write.table(prom,'promedios2.txt', sep = '\t')
```


```{r}
promedios1 <- read.table('promedios1.txt', sep = '\t', header = T)
```

```{r}
dim(promedios1)
```
```{r}
library(tibble)

promedios1 <- column_to_rownames(promedios1 , var = 'X')
dim(promedios1)
dim(prom)
colnames(promedios1) <- colnames(prom)
promediosTotal <- rbind(prom,promedios1)
promediosTotal <- promediosTotal[-c(1869)]

```


```{r}


pca.total <- prcomp(promediosTotal, scale = T, center = T)
vp <- (pca.total$sdev)^2
varianza <- round(vp/sum(vp)*100,2)
varianza
```

```{r}
coord <- pca.total$x

plot(coord[,1],
     coord[,2],
     pch = 19,
     xlab = paste('PC 1 -',as.character(varianza[1]), '%'),
     ylab = paste('PC 2 -',as.character(varianza[2]), '%')
     )
     

text(coord[,1],
     coord[,2],
     rownames(coord),
     cex = 1.1,
     pos = 1)

abline(h = 0, v = 0, lty= 2)
```
# Estimacion y correccion de lineas base

Es posible estimar las lineas base mediante el metodo `rubberband` del paquete `hyperspec`.


```{r}
library(hyperSpec)

spc <- new('hyperSpec', spc = promediosTotal, wavelength = wavenumber[-1869])
bend <- 0.1 * wl.eval (spc, function (x) x^7+x^6+x^5+x^4+x^3+x^2, normalize.wl=normalize01)

bl <- spc.rubberband (spc+bend, noise = 1e-4, df=20)-bend
suma <- spc+bend
spc3 <- spc - bl

plot(spc,wl.reverse = TRUE)
plot(bl, add=TRUE, col=2,wl.reverse = TRUE)

plot(suma,wl.reverse = TRUE)
plot(bend, add=TRUE, col=2,wl.reverse = TRUE)
plot(spc3,wl.reverse = TRUE)

corregido <- as.data.frame(spc3[1:31])
corregido2 <- as.data.frame(corregido[,1])
```

# PCA despues de correccion de linea base
```{r}

pca.bl <- prcomp(corregido2, scale =T, center = T)
vp.bl <- (pca.bl$sdev)^2
varianza.bl <- round(vp.bl/sum(vp.bl)*100, 2)
varianza.bl
```

```{r}
coord.bl <- pca.bl$x

plot(coord.bl[,1],
     coord.bl[,2],
     pch = 19,
     xlab = paste('PC 1 -',as.character(varianza.bl[1]), '%'),
     ylab = paste('PC 2 -',as.character(varianza.bl[2]), '%')
     )
     

text(coord.bl[,1],
     coord.bl[,2],
     rownames(coord.bl),
     cex = 1.1,
     pos = 1)

abline(h = 0, v = 0, lty= 2)
```

# 3D visualization


```{r}
rgl_init <- function(new.device = FALSE, bg = "white", width = 640) { 
  if( new.device | rgl.cur() == 0 ) {
    rgl.open()
    par3d(windowRect = 50 + c( 0, 0, width, width ) )
    rgl.bg(color = bg )
  }
  rgl.clear(type = c("shapes", "bboxdeco"))
  rgl.viewpoint(theta = 15, phi = 20, zoom = 0.7)
}
rgl_add_axes <- function(x, y, z, axis.col = "black",#52.20 42.79  3.75
                xlab =  paste('PC 1 -',as.character(varianza.bl[1]), '%'), 
                ylab=paste('PC 2 -',as.character(varianza.bl[2]), '%'), 
                zlab=paste('PC 3 -',as.character(varianza.bl[3]), '%'), 
                
                
                show.plane = FALSE, 
                show.bbox = TRUE, bbox.col = c("white","black"))
  { 
  
  lim <- function(x){c(-max(abs(x)), max(abs(x))) * 1.1}
  # Add axes
  xlim <- lim(x); ylim <- lim(y); zlim <- lim(z)
  rgl.lines(xlim, c(0, 0), c(0, 0), color = axis.col)
  rgl.lines(c(0, 0), ylim, c(0, 0), color = axis.col)
  rgl.lines(c(0, 0), c(0, 0), zlim, color = axis.col)
  
   # Add a point at the end of each axes to specify the direction
   axes <- rbind(c(xlim[2], 0, 0), c(0, ylim[2], 0), 
                 c(0, 0, zlim[2]))
   rgl.points(axes, color = axis.col, size = 3)
  
  # Add axis labels
  rgl.texts(axes, text = c(xlab, ylab, zlab), color = axis.col,
             adj = c(0.5, -0.8), size = 2)
  
  # # Add plane
  # if(show.plane) 
  #   xlim <- xlim/1.1; zlim <- zlim /1.1
  #   rgl.quads( x = rep(xlim, each = 2), y = c(0, 0, 0, 0),
  #            z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
  
  # Add bounding box decoration
  if(show.bbox){
    rgl.bbox(color=c(bbox.col[1],bbox.col[2]), alpha = 0.5, 
          emission=bbox.col[1], specular=bbox.col[1], shininess=5, 
          xlen = 3, ylen = 3, zlen = 3) 
  }
}
```

```{r}
library(rgl)
x  <- coord.bl[,1]
y  <- coord.bl[,2]
z  <- coord.bl[,3]
# here i make new vectors from the first 3 principal components in order to use them in graphical functions



rgl_init()
r3dDefaults$windowRect <- c(0,50, 1200, 1200)
rgl.spheres(x, y, z, r = 0.005, color = 'black')
rgl_add_axes(x, y, z, show.bbox = FALSE)
text3d(x,y+0.01,z, rownames(coord), col="black", pos=3, cex = 0.5)
aspect3d(1,1,1)
# browseURL(
#   paste("file://", writeWebGL(dir=file.path(tempdir(), "webGL"), 
#   width=800), sep="")
#   )



```

